/**
 *  Copyright 2010 Latiz Technologies, LLC
 *
 *  This file is part of Latiz.
 *
 *  Latiz is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  Latiz is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with Latiz.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.AandR.latiz.pluginPanel;

import com.AandR.library.gui.JHyperLink;
import com.AandR.library.gui.JSearchField.RewardingInterface;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import javax.swing.ActionMap;
import javax.swing.text.DefaultEditorKit;
import org.openide.explorer.ExplorerManager;
import org.openide.explorer.ExplorerUtils;
import org.openide.filesystems.FileObject;
import org.openide.filesystems.FileUtil;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.nodes.NodeNotFoundException;
import org.openide.nodes.NodeOp;
import org.openide.util.Exceptions;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.openide.windows.WindowManager;
//import org.openide.util.Utilities;

/**
 * Top component which displays something.
 */
final class PluginPanelTopComponent extends TopComponent implements ExplorerManager.Provider {

    private static final String PREFERRED_ID = "PluginPanelTopComponent";
    private static PluginPanelTopComponent instance;
    private ExplorerManager mgr;
    private FileObject pluginsFileObject;
    private List<Object> listToSearch;

    private PluginPanelTopComponent() {
        mgr = new ExplorerManager();
        ActionMap map = getActionMap();
        map.put(DefaultEditorKit.copyAction, ExplorerUtils.actionCopy(mgr));
        //map.put(DefaultEditorKit.cutAction, ExplorerUtils.actionCut(mgr));
        map.put(DefaultEditorKit.pasteAction, ExplorerUtils.actionPaste(mgr));
        map.put("delete", ExplorerUtils.actionDelete(mgr, true));
        associateLookup(ExplorerUtils.createLookup(mgr, map));

        initComponents();
        setName(NbBundle.getMessage(PluginPanelTopComponent.class, "CTL_PluginPanelTopComponent"));
        setToolTipText(NbBundle.getMessage(PluginPanelTopComponent.class, "HINT_PluginPanelTopComponent"));
//        setIcon(Utilities.loadImage(ICON_PATH, true));
        pluginsFileObject = FileUtil.getConfigRoot().getFileObject("plugins");
        if(pluginsFileObject==null) {
            AbstractNode n = new AbstractNode(Children.LEAF);
            n.setDisplayName("No installed plugins.");
            n.setIconBaseWithExtension("com/AandR/latiz/pluginPanel/noPluginIcon.png");
            mgr.setRootContext(n);
            return;
        }
        mgr.setRootContext(new GroupNode(pluginsFileObject));
    }

    public ExplorerManager getExplorerManager() {
        return mgr;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        beanTreeView = new org.openide.explorer.view.BeanTreeView();
        SearchFieldInterface searchFieldInterface = new SearchFieldInterface();
        searchField = new com.AandR.library.gui.JSearchField();
        searchField.setLinkListener(searchFieldInterface);
        searchField.setRewardingInterface(searchFieldInterface);
        jLabel1 = new javax.swing.JLabel();

        org.openide.awt.Mnemonics.setLocalizedText(jLabel1, "Find:"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(searchField, javax.swing.GroupLayout.DEFAULT_SIZE, 116, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(beanTreeView, javax.swing.GroupLayout.DEFAULT_SIZE, 164, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(searchField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel1))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(beanTreeView, javax.swing.GroupLayout.DEFAULT_SIZE, 136, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private org.openide.explorer.view.BeanTreeView beanTreeView;
    private javax.swing.JLabel jLabel1;
    private com.AandR.library.gui.JSearchField searchField;
    // End of variables declaration//GEN-END:variables

    /**
     * Gets default instance. Do not use directly: reserved for *.settings files only,
     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.
     * To obtain the singleton instance, use {@link #findInstance}.
     */
    public static synchronized PluginPanelTopComponent getDefault() {
        if (instance == null) {
            instance = new PluginPanelTopComponent();
        }
        return instance;
    }

    /**
     * Obtain the PluginPanelTopComponent instance. Never call {@link #getDefault} directly!
     */
    public static synchronized PluginPanelTopComponent findInstance() {
        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);
        if (win == null) {
            Logger.getLogger(PluginPanelTopComponent.class.getName()).warning(
                    "Cannot find " + PREFERRED_ID + " component. It will not be located properly in the window system.");
            return getDefault();
        }
        if (win instanceof PluginPanelTopComponent) {
            return (PluginPanelTopComponent) win;
        }
        Logger.getLogger(PluginPanelTopComponent.class.getName()).warning(
                "There seem to be multiple components with the '" + PREFERRED_ID +
                "' ID. That is a potential source of errors and unexpected behavior.");
        return getDefault();
    }

    @Override
    public int getPersistenceType() {
        return TopComponent.PERSISTENCE_ALWAYS;
    }

    @Override
    public void componentOpened() {
        listToSearch = new ArrayList<Object>();
        addDirectoryToSearchList(listToSearch, pluginsFileObject);
        searchField.setListToSearch(listToSearch);
    }

    private void addDirectoryToSearchList(List<Object> listToSearch, FileObject fo) {
        if(fo==null) return;
        for (FileObject f : fo.getChildren()) {
            if (f.isFolder()) {
                addDirectoryToSearchList(listToSearch, f);
            } else {
                int l = f.getPath().lastIndexOf(".instance");
                listToSearch.add(f.getPath().substring(0, l));
            }
        }
    }

    @Override
    public void componentClosed() {
    }

    /** replaces this in object stream */
    @Override
    public Object writeReplace() {
        ArrayList<String[]> paths = new ArrayList<String[]>();
        updateExpansionList(paths, mgr.getRootContext());
        return new ResolvableHelper(paths);
    }

    private void updateExpansionList(ArrayList<String[]> paths, Node contextNode) {
        Children children = contextNode.getChildren();
        Node root = mgr.getRootContext();
        Node[] nodes = children.getNodes();
        for(Node node : nodes) {
            if(beanTreeView.isExpanded(node)) {
                paths.add(NodeOp.createPath(node, root));
                updateExpansionList(paths, node);
            }
        }
    }

    @Override
    protected String preferredID() {
        return PREFERRED_ID;
    }

    final static class ResolvableHelper implements Serializable {

        private static final long serialVersionUID = 1L;

        private ArrayList<String[]> paths;

        private ResolvableHelper(ArrayList<String[]> paths) {
            this.paths = paths;
        }

        public Object readResolve() {
            PluginPanelTopComponent result = PluginPanelTopComponent.getDefault();
            if(paths==null || paths.isEmpty()) return result;
            for(String[] path : paths) {
                try {
                    Node nodeToExpand = NodeOp.findPath(result.mgr.getRootContext(), path);
                    if(nodeToExpand != null) {
                        result.beanTreeView.expandNode(nodeToExpand);
                    }
                } catch (NodeNotFoundException ex) {
                    Exceptions.printStackTrace(ex);
                }
            }
            return result;
        }
    }

    /**
     * 
     */
    private class SearchFieldInterface implements ActionListener, RewardingInterface {

        public void actionPerformed(ActionEvent e) {
            JHyperLink hyperlink = (JHyperLink) e.getSource();
            searchField.setResultsVisible(false);
            try {
                int startIndex = 8; //Used to strip of the root node "plugins/"
//                FileObject fo = Repository.getDefault().getDefaultFileSystem().findResource(hyperlink.getText() + ".instance");
                FileObject fo = FileUtil.getConfigRoot().getFileSystem().findResource(hyperlink.getText() + ".instance");
                String folderPath = fo.getParent().getPath();
                String subPath = folderPath.substring(startIndex);
                String[] pathSplit = subPath.split("/");
                Node nodeToExpand = NodeOp.findPath(mgr.getRootContext(), pathSplit);
                beanTreeView.expandNode(nodeToExpand);

                String filePath = fo.getPath();
                String subFile = filePath.substring(startIndex, filePath.lastIndexOf(".instance"));
                String[] fileSplit = subFile.split("/");
                Node nodeToSelect = NodeOp.findPath(mgr.getRootContext(), fileSplit);
                mgr.setSelectedNodes(new Node[]{nodeToSelect});
            } catch (Exception ex) {
            }
        }

        public Number computeReward(String request, Object o) {
            int metric = 0;
            String sl = o.toString().toLowerCase();
            String rl = request.toLowerCase();
            if (sl.contains(rl)) {
                metric++;
            }
            String[] path = sl.split("/");
            for (String thisPathSegment : path) {
                if (thisPathSegment.equals(rl)) {
                    metric++;
                }
                if (thisPathSegment.startsWith(rl)) {
                    metric++;
                }
            }
            if (path[path.length - 1].equals(rl)) {
                metric++;
            }

            if (sl.equals(rl)) {
                metric++;
            }
            return metric;
        }
    }
}
